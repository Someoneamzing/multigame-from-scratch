/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./client/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./client/js/classes/Camera.js":
/*!*************************************!*\
  !*** ./client/js/classes/Camera.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("let client = class {\n  constructor(ctx, { x, y, zoom }) {\n    this.ctx = ctx;\n    this.x = x;\n    this.y = y;\n    this.zoom = zoom;\n  }\n\n  setPos(x = 0, y = 0) {\n    if (typeof x == 'object') {\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      this.x = x;\n      this.y = y;\n    }\n  }\n};\n\nmodule.exports = { client };\n\n//# sourceURL=webpack:///./client/js/classes/Camera.js?");

/***/ }),

/***/ "./client/js/classes/Canvas.js":
/*!*************************************!*\
  !*** ./client/js/classes/Canvas.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const CameraProxy = __webpack_require__(/*! ./Camera.js */ \"./client/js/classes/Camera.js\");\n\nlet client = class {\n  constructor(ctx, hasMini = false, camera = new CameraProxy.client(ctx, { x: 0, y: 0, zoom: 1 })) {\n    this.ctx = ctx;\n    this.canvas = $(this.ctx.canvas);\n    this.camera = camera;\n    this.minimap = hasMini !== false ? new client(hasMini, false, new CameraProxy.client(this.hasMini, { x: 0, y: 0, zoom: 0.1 })) : false;\n    console.log(this.minimap);\n  }\n\n  get width() {\n    return this.canvas.width();\n  }\n\n  get height() {\n    return this.canvas.height();\n  }\n\n  resize({ w, h }) {\n    this.ctx.canvas.width = w;\n    this.ctx.canvas.height = h;\n    this.colour('red');\n    this.rect({ x: 0, y: 0, w: this.width, h: this.height }, true);\n  }\n\n  rect({ x, y, w, h }, outline) {\n    if (outline) {\n      this.ctx.strokeRect(x, y, w, h);\n    } else {\n      this.ctx.fillRect(x, y, w, h);\n    }\n  }\n\n  centerRect({ x, y, w, h }, outline) {\n    if (outline) {\n      this.ctx.strokeRect(x - w / 2, y - h / 2, w, h);\n    } else {\n      this.ctx.fillRect(x - w / 2, y - h / 2, w, h);\n    }\n  }\n\n  colour(colour) {\n    this.ctx.fillStyle = colour;\n    this.ctx.strokeStyle = colour;\n  }\n\n  text(str, x, y) {\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(str, x, y);\n  }\n\n  textWO(str, x, y, fill, line) {\n    let old = this.ctx.fillStyle;\n    let lineW = this.ctx.lineWidth;\n    this.ctx.fillStyle = fill;\n    this.ctx.lineWidth = 1;\n    this.ctx.strokeStyle = line;\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText(str, x, y);\n    this.ctx.strokeText(str, x, y);\n    this.colour(old);\n    this.lineWidth(lineW);\n  }\n\n  lineWidth(w) {\n    this.ctx.lineWidth = w;\n  }\n\n  font(f) {\n    this.ctx.font = f;\n  }\n\n  clear() {\n    this.ctx.clearRect(0, 0, this.canvas.width(), this.canvas.height());\n  }\n\n  update() {\n    this.ctx.save();\n    if (this.minimap) {\n      this.minimap.clear();\n      this.minimap.camera.setPos(this.camera.x, this.camera.y);\n      this.minimap.update();\n    }\n    //console.log(this.camera.x,this.camera.y);\n    this.ctx.scale(this.camera.zoom, this.camera.zoom);\n    this.ctx.translate(-(this.camera.x - this.width / (2 * this.camera.zoom)), -(this.camera.y - this.height / (2 * this.camera.zoom)));\n  }\n\n  reset() {\n    this.ctx.restore();\n    if (this.minimap) {\n      this.minimap.reset();\n    }\n  }\n\n  background(image) {\n    let { x, y } = this.camera;\n    const { w: a, h: b } = image;\n    const { width: w, height: h } = this;\n    x = x - w;\n    y = y - h;\n    let C = [{ n: (x - x % a) / a, m: (y - y % b) / b }, { n: (x + w - (x + w) % a) / a + 2, m: (y - y % b) / b }, { n: (x - x % a) / a, m: (y + h - (y + h) % b) / b + 2 }];\n    let imax = C[1].n - C[0].n;\n    let jmax = C[2].m - C[0].m;\n    //console.log(imax, jmax);\n    for (let i = 0; i <= imax; i++) {\n      for (let j = 0; j <= jmax; j++) {\n        image.drawCenter(this, { x: (C[0].n + i) * a, y: (C[0].m + j) * b, w: a, h: b });\n        //image.drawCenter(this.minimap, {x: (C[0].n + i) * a, y: (C[0].m + j) * b, w: a, h: b});\n      }\n    }\n  }\n};\n\nmodule.exports = { client };\n\n//# sourceURL=webpack:///./client/js/classes/Canvas.js?");

/***/ }),

/***/ "./client/js/classes/Decoration.js":
/*!*****************************************!*\
  !*** ./client/js/classes/Decoration.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EntityProxy = __webpack_require__(/*! ./Entity.js */ \"./client/js/classes/Entity.js\");\nclass client extends EntityProxy.client {\n  constructor(params) {\n    super(params);\n    const { category, variant, health, healthMax } = params;\n    this.category = category;\n    this.variant = variant;\n    console.log(category, variant);\n    this.health = health;\n    this.healthMax = healthMax;\n    this.sprite = Sprites.get('decoration_' + this.category + \"_\" + this.variant);\n\n    client.list[this.id] = this;\n  }\n\n  render(canvas) {\n    this.sprite.drawCenter(canvas, this);\n  }\n\n  remove() {\n    delete this.constructor.list[this.id];\n    super.remove();\n  }\n\n  update(pkt) {\n    this.category = pkt.category;\n    this.variant = pkt.variant;\n    super.update(pkt);\n    if (this.x > canvas.camera.x - canvas.width / 2 && this.x < canvas.camera.x + canvas.width / 2 && this.y > canvas.camera.y - canvas.height / 2 && this.y < canvas.camera.y + canvas.height / 2) client.visible.push(this);\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(client.trackName);\n    return inst;\n  }\n}\n\nclass server extends EntityProxy.server {\n  constructor(params) {\n    super(params);\n    const { category, variant, health, healthMax } = params;\n    this.category = category;\n    this.variant = variant;\n    this.health = health;\n    this.healthMax = healthMax;\n\n    server.list[this.id] = this;\n    initPack[server.trackName][this.id] = this.getInitPkt();\n  }\n\n  getInitPkt() {\n    let pkt = super.getInitPkt();\n    pkt.category = this.category;\n    pkt.variant = this.variant;\n    return pkt;\n  }\n\n  getUpdatePkt() {\n    let pkt = super.getInitPkt();\n    pkt.category = this.category;\n    pkt.variant = this.variant;\n    return pkt;\n  }\n\n  update() {\n\n    super.update();\n  }\n\n  damage(amount, p) {\n    this.health = Math.max(this.health - amount, 0);\n    if (this.health <= 0) this.kill(p);\n  }\n\n  kill(p) {\n    p.exp += Math.floor(Math.random() * 3);\n    this.remove();\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(server.trackName);\n    return inst;\n  }\n\n  static getUpdate() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      if (obj.dirty) pkt[objId] = obj.getUpdatePkt();\n    }\n    return pkt;\n  }\n\n  static getInit() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      pkt[objId] = obj.getInitPkt();\n    }\n    return pkt;\n  }\n}\n\nclient.trackName = server.trackName = \"Decoration\";\nserver.list = {};\nclient.list = {};\nclient.visible = [];\nmodule.exports = { client, server };\n\n//# sourceURL=webpack:///./client/js/classes/Decoration.js?");

/***/ }),

/***/ "./client/js/classes/Entity.js":
/*!*************************************!*\
  !*** ./client/js/classes/Entity.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const TrackableProxy = __webpack_require__(/*! ./Trackable.js */ \"./client/js/classes/Trackable.js\");\n\nlet client = class extends TrackableProxy.client {\n  constructor(params) {\n    super(params);\n    const { x = 0, y = 0, world = 0, w = 32, h = 32 } = params;\n    this.x = x;\n    this.y = y;\n    this.world = world;\n    this.w = w;\n    this.h = h;\n\n    client.list[this.id] = this;\n  }\n\n  render(canvas) {\n    canvas.colour('purple');\n    canvas.centerRect(this);\n  }\n\n  update(pkt) {\n    this.x = pkt.x;\n    this.y = pkt.y;\n    this.world = pkt.world;\n    super.update(pkt);\n  }\n\n  remove() {\n    //server.trackList.remove[server.trackName].push(this.id);\n    // if (!global.removePack[this.constructor.trackName].includes(this.id)) global.removePack[this.constructor.trackName].push(this.id);\n    delete this.constructor.list[this.id];\n    super.remove();\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(client.trackName);\n    return inst;\n  }\n};\n\nlet server = class extends TrackableProxy.server {\n  constructor(params) {\n    super(params);\n    const { x = 0, y = 0, world = 0, w = 32, h = 32, solid = false } = params;\n    this.x = x;\n    this.y = y;\n    this.world = world;\n    this.w = w;\n    this.h = h;\n    this.hsp = 0;\n    this.vsp = 0;\n    this.solid = solid;\n\n    server.list[this.id] = this;\n    console.log(super.type);\n  }\n\n  dist(obj, x = this.x, y = this.y) {\n    return Math.pow(obj.x - x, 2) + Math.pow(obj.y - y, 2);\n  }\n\n  collision(x, y, onlySolid, type) {\n\n    for (let objName in CollisionTree.retrieve(this)) {\n      let obj = server.list[objName];\n      if (!obj) continue;\n      if (obj.id == this.id) continue;\n      if (typeof type != 'undefined' && !obj.type.includes(type)) continue;\n      if (onlySolid && !obj.solid) continue;\n      //if (this.dist(obj,x,y)>(Math.pow(this.w/2,2)+Math.pow(this.h/2,2))) continue;\n      if (x - this.w / 2 > obj.x + obj.w / 2 || x + this.w / 2 < obj.x - obj.w / 2) continue;\n      if (y - this.h / 2 > obj.y + obj.h / 2 || y + this.h / 2 < obj.y - obj.h / 2) continue;\n      return obj;\n    }\n    return false;\n  }\n\n  update() {\n    if (this.collision(this.x + this.hsp, this.y, true)) {\n      while (!this.collision(this.x + Math.sign(this.hsp), this.y, true)) {\n        this.x += Math.sign(this.hsp);\n      }\n      this.hsp = 0;\n    }\n\n    this.x += this.hsp;\n\n    if (this.collision(this.x, this.y + this.vsp, true)) {\n      while (!this.collision(this.x, this.y + Math.sign(this.vsp), true)) {\n        this.y += Math.sign(this.vsp);\n      }\n      this.vsp = 0;\n    }\n\n    this.y += this.vsp;\n\n    this.markDirty();\n  }\n\n  remove() {\n    super.remove();\n    delete server.list[this.id];\n  }\n\n  getInitPkt() {\n    let pkt = super.getInitPkt();\n    pkt.x = this.x;\n    pkt.y = this.y;\n    pkt.w = this.w;\n    pkt.h = this.h;\n    pkt.world = this.world;\n    return pkt;\n  }\n\n  getUpdatePkt() {\n    let pkt = super.getUpdatePkt();\n    pkt.x = this.x;\n    pkt.y = this.y;\n    pkt.world = this.world;\n    return pkt;\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(server.trackName);\n    return inst;\n  }\n\n  static registerCollidables() {\n    CollisionTree.clear();\n    for (let i in server.list) {\n      CollisionTree.insert(server.list[i]);\n    }\n  }\n};\n\n//console.log(server.getUpdate());\nmodule.exports = { client, server };\n\n//# sourceURL=webpack:///./client/js/classes/Entity.js?");

/***/ }),

/***/ "./client/js/classes/Inventory.js":
/*!****************************************!*\
  !*** ./client/js/classes/Inventory.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const ItemProxy = __webpack_require__(/*! ./Item.js */ \"./client/js/classes/Item.js\");\n\nlet client = class {\n  constructor({ size = 1, hotbarSize = 0 }) {\n    this.size = size - hotbarSize;\n    this.hotbarSize = hotbarSize;\n    this.totalSize = size;\n    this.list = [];\n    this.hotbar = [];\n    this.selectedSlot = 0;\n    this.clear();\n  }\n\n  get selected() {\n    return this.hotbar[this.selectedSlot];\n  }\n\n  update(hotbar, list, selectedSlot) {\n    this.hotbar = hotbar;\n    this.list = list;\n    this.selectedSlot = selectedSlot;\n  }\n\n  clear() {\n    for (let i = 0; i < this.size; i++) {\n      this.list[i] = { count: 0, item: null };\n    }\n    for (let i = 0; i < this.hotbarSize; i++) {\n      this.hotbar[i] = { count: 0, item: null };\n    }\n  }\n};\n\nlet server = class {\n  constructor({ size = 1, hotbarSize = 0 }) {\n    this.size = size - hotbarSize;\n    this.hotbarSize = hotbarSize;\n    this.totalSize = size;\n    this.list = [];\n    this.hotbar = [];\n    this.selectedSlot = 0;\n    this.clear();\n  }\n\n  get selected() {\n    return this.hotbar[this.selectedSlot];\n  }\n\n  drop(from, slot, amount = Infinity, x = 0, y = 0) {\n    let type = this[from][slot].item;\n    if (type == null) return 0;\n    let count = Math.min(this[from][slot].count, amount);\n    if (count == 0) return 0;\n    this[from][slot].count -= count;\n    if (this[from][slot].count <= 0) this[from][slot].item = null;\n    new ItemProxy.server({ item: type, count, x, y, delay: 100 });\n    return count;\n  }\n\n  remove(from, slot, amount) {\n    if (from == 'any') {\n      let int = this.getFirst(slot);\n      slot = int.slot;\n      from = int.from;\n      if (slot <= -1) return;\n    }\n    let type = this[{ 'hotbar': 'hotbar', 'inventory': 'list' }[from]][slot].item;\n    if (type == null) return 0;\n    let count = Math.min(this[from][slot].count, amount);\n    if (count == 0) return 0;\n    this[from][slot].count -= count;\n    if (this[from][slot].count <= 0) this[from][slot].item = null;\n    return count;\n  }\n\n  getFirst(type, from = 'any') {\n    switch (from) {\n      case 'inventory':\n        return this.list.findIndex(item => {\n          return item.item == type;\n        });\n        break;\n\n      case 'hotbar':\n        return this.hotbar.findIndex(item => {\n          return item.item == type;\n        });\n        break;\n\n      case 'any':\n        let i = this.hotbar.findIndex(item => {\n          return item.item == type;\n        });\n\n        if (i > -1) return { slot: i, from: 'hotbar' };\n\n        return { slot: this.list.findIndex(item => {\n            return item.item == type;\n          }), from: 'inventory' };\n    }\n  }\n\n  add(type, amount, to = 'any', slot) {\n    let total = amount;\n    if (amount == 0) {\n      console.log('Error in amount');return 0;\n    }\n    if (type == null) {\n      console.log('Error in type');return 0;\n    }\n    if (!['any', 'hotbar', 'inventory'].includes(to)) {\n      console.log('Error in to');return 0;\n    }\n    switch (to) {\n      case 'any':\n        for (let i = 0; i < this.hotbarSize; i++) {\n          if (this.hotbar[i].count > 99 || this.hotbar[i].item != null && this.hotbar[i].item != type) continue;\n          let item = this.hotbar[i];\n          let toAdd = Math.min(amount, 99 - item.count);\n          if (item.item == null) {\n            item.item = type;\n          }\n          item.count += toAdd;\n          amount -= toAdd;\n          if (amount <= 0) break;\n        }\n        if (amount <= 0) return total;\n        for (let i = 0; i < this.size; i++) {\n          if (this.list[i].count > 99 || this.list[i].item != null && this.list[i].item != type) continue;\n          let item = this.list[i];\n          let toAdd = Math.min(amount, 99 - item.count);\n          if (item.item == null) {\n            item.item = type;\n          }\n          item.count += toAdd;\n          amount -= toAdd;\n          if (amount <= 0) break;\n        }\n        if (amount <= 0) return total;\n        return total - amount;\n        break;\n\n      case 'hotbar':\n        if (typeof slot != 'undefined') {\n          if (this.hotbar[slot].count > 99 || this.hotbar[slot].item != null && this.hotbar[slot].item != type) return 0;\n          let item = this.hotbar[slot];\n          let toAdd = Math.min(amount, 99 - item.count);\n          if (item.item == null) {\n            item.item = type;\n          }\n          item.count += toAdd;\n          amount -= toAdd;\n          return total - amount;\n        }\n        for (let i = 0; i < this.hotbarSize; i++) {\n          if (this.hotbar[i].count > 99 || this.hotbar[i].item != null && this.hotbar[i].item != type) continue;\n          let item = this.hotbar[i];\n          let toAdd = Math.min(amount, 99 - item.count);\n          if (item.item == null) {\n            item.item = type;\n          }\n          item.count += toAdd;\n          amount -= toAdd;\n          if (amount <= 0) break;\n        }\n        if (amount <= 0) return total;\n        return total - amount;\n        break;\n\n      case 'inventory':\n        if (typeof slot != 'undefined') {\n          if (this.hotbar[slot].count > 99 || this.hotbar[slot].item != null && this.hotbar[slot].item != type) return 0;\n          let item = this.hotbar[slot];\n          let toAdd = Math.min(amount, 99 - item.count);\n          if (item.item == null) {\n            item.item = type;\n          }\n          item.count += toAdd;\n          amount -= toAdd;\n          return total - amount;\n        }\n        for (let i = 0; i < this.size; i++) {\n          if (this.list[i].count > 99 || this.list[i].item != null && this.list[i].item != type) continue;\n          let item = this.list[i];\n          let toAdd = Math.min(amount, 99 - item.count);\n          if (item.item == null) {\n            item.item = type;\n          }\n          item.count += toAdd;\n          amount -= toAdd;\n          if (amount <= 0) break;\n        }\n        if (amount <= 0) return total;\n        return total - amount;\n        break;\n    }\n  }\n\n  set(to, slot, amount, type) {\n    if (!['hotbar', 'inventory'].includes(to) || slot > this[to == 'inventory' ? 'list' : to].length - 1) return false;\n    this[to == 'inventory' ? 'list' : to][slot] = { type: type ? type : this[to == 'inventory' ? 'list' : to][slot].item, count: Math.min(99, Math.max(0, amount)) };\n    return true;\n  }\n\n  clear() {\n    for (let i = 0; i < this.size; i++) {\n      this.list[i] = { count: 0, item: null };\n    }\n    for (let i = 0; i < this.hotbarSize; i++) {\n      this.hotbar[i] = { count: 0, item: null };\n    }\n  }\n\n};\n\nmodule.exports = { client, server };\n\n//# sourceURL=webpack:///./client/js/classes/Inventory.js?");

/***/ }),

/***/ "./client/js/classes/Item.js":
/*!***********************************!*\
  !*** ./client/js/classes/Item.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EntityProxy = __webpack_require__(/*! ./Entity.js */ \"./client/js/classes/Entity.js\");\n\nlet client = class extends EntityProxy.client {\n  constructor(params) {\n    super(params);\n    const { item, count } = params;\n    this.item = item;\n    this.count = count;\n\n    client.list[this.id] = this;\n  }\n\n  render(canvas) {\n    Sprites.get('item_' + this.item).drawCenter(canvas, this);\n    //super.render(canvas);\n  }\n\n  remove() {\n    delete this.constructor.list[this.id];\n    super.remove();\n  }\n\n  update(pkt) {\n    this.item = pkt.item;\n    this.count = pkt.count;\n    super.update(pkt);\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(client.trackName);\n    return inst;\n  }\n};\n\nlet server = class extends EntityProxy.server {\n  constructor(params) {\n    super(params);\n    const { item, count, delay } = params;\n    this.item = item;\n    this.count = count;\n    this.delay = delay;\n\n    server.list[this.id] = this;\n    initPack[server.trackName][this.id] = this.getInitPkt();\n  }\n\n  getInitPkt() {\n    let pkt = super.getInitPkt();\n    pkt.item = this.item;\n    pkt.count = this.count;\n    return pkt;\n  }\n\n  getUpdatePkt() {\n    let pkt = super.getUpdatePkt();\n    pkt.item = this.item;\n    pkt.count = this.count;\n    return pkt;\n  }\n\n  update() {\n    let p = this.collision(this.x, this.y, false, 'Player');\n    if (this.delay <= 0 && p && !p.dead) {\n      let added = p.inventory.add(this.item, this.count, 'any');\n      this.count -= added;\n      console.log(added, this.count);\n      if (this.count <= 0) this.remove();\n    }\n    this.delay = Math.max(this.delay - 1, 0);\n    super.update();\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(server.trackName);\n    return inst;\n  }\n\n  static getUpdate() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      if (obj.dirty) pkt[objId] = obj.getUpdatePkt();\n    }\n    return pkt;\n  }\n\n  static getInit() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      pkt[objId] = obj.getInitPkt();\n    }\n    return pkt;\n  }\n};\nclient.trackName = server.trackName = \"Item\";\nserver.list = {};\nclient.list = {};\nmodule.exports = { client, server };\n\n//# sourceURL=webpack:///./client/js/classes/Item.js?");

/***/ }),

/***/ "./client/js/classes/LoaderList.js":
/*!*****************************************!*\
  !*** ./client/js/classes/LoaderList.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("let client = class {\n  constructor(loaders) {\n    this.loaders = loaders;\n  }\n\n  async load(indicator, cb) {\n    for (let loader of this.loaders) {\n      await loader.load(indicator);\n    }\n    cb();\n  }\n};\nmodule.exports = { client };\n\n//# sourceURL=webpack:///./client/js/classes/LoaderList.js?");

/***/ }),

/***/ "./client/js/classes/Player.js":
/*!*************************************!*\
  !*** ./client/js/classes/Player.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EntityProxy = __webpack_require__(/*! ./Entity.js */ \"./client/js/classes/Entity.js\");\nconst InventoryProxy = __webpack_require__(/*! ./Inventory.js */ \"./client/js/classes/Inventory.js\");\n\nlet client = class extends EntityProxy.client {\n  constructor(params) {\n    super(params);\n    const { name, inventory, maxMana, mana, maxHealth, health, selectedSlot, exp, toNextL, level } = params;\n    this.name = name;\n    this.maxHealth = maxHealth;\n    this.health = health;\n    this.maxMana = maxMana;\n    this.mana = mana;\n    this.exp = exp;\n    this.toNextL = toNextL;\n    this.level = level;\n    this.inventory = new InventoryProxy.client(inventory);\n\n    client.list[this.id] = this;\n  }\n\n  render(canvas) {\n    super.render(canvas);\n    canvas.minimap.colour('lime');\n    canvas.minimap.centerRect(this);\n    canvas.font('10px Arial');\n    canvas.colour('black');\n    canvas.text(this.name, this.x, this.y - this.h / 0.8);\n    canvas.text(\"Level: \" + this.level, this.x, this.y - this.h / 0.6);\n    canvas.colour('red');\n    canvas.rect({ x: this.x - this.w / 2, y: this.y - this.w, w: 32, h: 5 });\n    canvas.colour('green');\n    canvas.rect({ x: this.x - this.w / 2, y: this.y - this.w, w: 32 * (this.health / this.maxHealth), h: 5 });\n  }\n\n  update(pkt) {\n    this.inventory.update(pkt.inventory.hotbar, pkt.inventory.list, pkt.inventory.selectedSlot);\n    this.health = pkt.health;\n    this.maxHealth = pkt.maxHealth;\n    this.mana = pkt.mana;\n    this.maxMana = pkt.maxMana;\n    this.exp = pkt.exp;\n    this.toNextL = pkt.toNextL;\n    this.level = pkt.level;\n    delete pkt.inventory;\n    super.update(pkt);\n  }\n\n  remove() {\n    //server.trackList.remove[server.trackName].push(this.id);\n    // if (!global.removePack[this.constructor.trackName].includes(this.id)) global.removePack[this.constructor.trackName].push(this.id);\n    delete this.constructor.list[this.id];\n    super.remove();\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(client.trackName);\n    return inst;\n  }\n};\n\nlet server = class extends EntityProxy.server {\n  constructor(params) {\n    super(params);\n    const { name = 'player', socket, moveSpeed = 5, maxHealth = 20, health = maxHealth, maxMana = 100, mana = maxMana } = params;\n    this.name = name;\n    this.socket = socket;\n    this.moveSpeed = moveSpeed;\n    this.keys = {};\n    this.dead = false;\n    this.deathTime = 0;\n    this.mouse = { button: 0, x: this.x, y: this.y };\n    this.mouseThisTick = 0;\n    this.maxHealth = maxHealth;\n    this.health = health;\n    this.maxMana = maxMana;\n    this.mana = mana;\n    this.exp = 0;\n    this.toNextL = 100;\n    this.level = 0;\n    this.inventory = new InventoryProxy.server({ size: 36, hotbarSize: 9 });\n\n    server.list[this.id] = this;\n    initPack[server.trackName][this.id] = this.getInitPkt();\n    //console.log(initPack[server.trackName][this.id]);\n  }\n\n  getInitPkt() {\n    let pkt = super.getInitPkt();\n    pkt.name = this.name;\n    pkt.maxHealth = this.maxHealth;\n    pkt.health = this.health;\n    pkt.maxMana = this.maxMana;\n    pkt.mana = this.mana;\n    pkt.exp = this.exp;\n    pkt.toNextL = this.toNextL;\n    pkt.level = this.level;\n    pkt.inventory = { size: this.inventory.totalSize, hotbarSize: this.inventory.hotbarSize };\n    return pkt;\n  }\n\n  update() {\n    if (!this.dead) {\n      if (this.toNextL <= this.exp) {\n        this.level++;\n        this.exp -= this.toNextL;\n        this.toNextL += this.level * 10;\n      }\n      this.hsp = (Number(Boolean(this.keys[\"D\"]) || Boolean(this.keys[\"ARROWRIGHT\"])) - Number(Boolean(this.keys[\"A\"]) || Boolean(this.keys[\"ARROWLEFT\"]))) * this.moveSpeed;\n      this.vsp = (Number(Boolean(this.keys[\"S\"]) || Boolean(this.keys[\"ARROWDOWN\"])) - Number(Boolean(this.keys[\"W\"]) || Boolean(this.keys[\"ARROWUP\"]))) * this.moveSpeed;\n\n      if (this.mouseThisTick == 1) {\n        let tool = global.Tool.get(this.inventory.selected.item);\n        if (tool) {\n          tool.use(this);\n        } else {\n          let deco = this.collision(this.x, this.y, false, 'Tree') || this.collision(this.x, this.y, false, 'Rock');\n          if (deco) {\n            deco.damage(1, this);\n          }\n        }\n      }\n\n      if (this.mouseThisTick == 3) {\n        let cons = global.Consumable.get(this.inventory.selected.item);\n        if (cons) cons.use(this, this.inventory.selectedSlot);\n      }\n\n      if (this.keys[1] || this.keys[2] || this.keys[3] || this.keys[4] || this.keys[5] || this.keys[6] || this.keys[7] || this.keys[8] || this.keys[9]) {\n        let test = [];\n        for (let i = 1; i < 10; i++) {\n          if (this.keys[i]) test.push(i);\n        }\n        this.inventory.selectedSlot = test[0] ? test[0] - 1 : this.inventory.selectedSlot;\n      }\n\n      this.mouseThisTick = 0;\n      super.update();\n    } else {\n      this.deathTime--;\n      if (this.deathTime <= 0) this.respawn();\n    }\n  }\n\n  respawn() {\n    this.x = 0;\n    this.y = 0;\n    this.dead = false;\n    this.deathTime = 0;\n    this.exp = 0;\n    this.health = this.maxHealth;\n    this.mana = this.maxMana;\n    this.socket.emit('respawn');\n  }\n\n  damage(damage, p) {\n    if (this.dead) return;\n    this.health = Math.max(this.health - damage, 0);\n    if (this.health <= 0) {\n      this.kill(p);\n    } else {\n      this.socket.emit('damage', damage);\n    }\n  }\n\n  heal(amount) {\n    if (this.dead) return;\n    this.health = Math.min(this.maxHealth, this.health + amount);\n  }\n\n  kill(p) {\n    this.dead = true;\n    this.deathTime = 300;\n    this.hsp = this.vsp = 0;\n    for (let key in this.keys) this.keys[key] = false;\n    for (let i = 0; i < this.inventory.hotbarSize; i++) {\n      this.inventory.drop('hotbar', i, Infinity, this.x, this.y);\n    }\n    for (let i = 0; i < this.inventory.size; i++) {\n      this.inventory.drop('list', i, Infinity, this.x, this.y);\n    }\n    p.exp += Math.floor(Math.random() * 10);\n    this.socket.emit('kill', p.name);\n  }\n\n  getUpdatePkt() {\n    let pkt = super.getUpdatePkt();\n    pkt.name = this.name;\n    pkt.maxHealth = this.maxHealth;\n    pkt.health = this.health;\n    pkt.maxMana = this.maxMana;\n    pkt.mana = this.mana;\n    pkt.exp = this.exp;\n    pkt.toNextL = this.toNextL;\n    pkt.level = this.level;\n    pkt.inventory = { list: this.inventory.list, hotbar: this.inventory.hotbar, selectedSlot: this.inventory.selectedSlot };\n    return pkt;\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(server.trackName);\n    return inst;\n  }\n\n  render(ctx) {\n    ctx.fillStyle = '#00ff00';\n    ctx.fillRect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h);\n  }\n\n  static getUpdate() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      if (obj.dirty) pkt[objId] = obj.getUpdatePkt();\n    }\n    return pkt;\n  }\n\n  static getInit() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      pkt[objId] = obj.getInitPkt();\n    }\n    return pkt;\n  }\n\n  static broadcast(e, m) {\n    for (let id in server.list) {\n      server.list[id].socket.emit(e, m);\n    }\n  }\n\n  // static getRemove(){\n  //   let pkt = {};\n  //   for (let objId in server.list){\n  //     let obj = server.list[objId];\n  //     if (obj.dirty) pkt[objId] = obj.getRemovePkt();\n  //   }\n  //   return pkt;\n  // }\n};\n\nserver.list = {};\nclient.list = {};\n\n//console.log(EntityProxy.server.getUpdate());\n\nmodule.exports = { client, server };\n\n//# sourceURL=webpack:///./client/js/classes/Player.js?");

/***/ }),

/***/ "./client/js/classes/Projectile.js":
/*!*****************************************!*\
  !*** ./client/js/classes/Projectile.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EntityProxy = __webpack_require__(/*! ./Entity.js */ \"./client/js/classes/Entity.js\");\n\nlet client = class extends EntityProxy.client {\n  constructor(params) {\n    super(params);\n    const { variant, rot } = params;\n    this.variant = variant;\n    this.rot = rot;\n\n    client.list[this.id] = this;\n    console.log('New Projectile', client.list);\n  }\n\n  render(canvas) {\n    Sprites.get('proj_' + this.variant).drawCenter(canvas, this);\n  }\n\n  update(pkt) {\n    this.rot = pkt.rot;\n    super.update(pkt);\n  }\n\n  remove() {\n    delete client.list[this.id];\n    super.remove();\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(client.trackName);\n    return inst;\n  }\n};\n\nlet server = class extends EntityProxy.server {\n  constructor(params) {\n    super(params);\n    const { variant, damage, pId, hsp, vsp } = params;\n    this.variant = variant;\n    this.damage = damage;\n    this.pId = pId;\n    this.age = 0;\n    this.hsp = hsp;\n    this.vsp = vsp;\n\n    server.list[this.id] = this;\n    initPack[server.trackName][this.id] = this.getInitPkt();\n  }\n\n  get rot() {\n    return Math.atan2(this.vsp, this.hsp);\n  }\n\n  getInitPkt() {\n    let pkt = super.getInitPkt();\n    pkt.variant = this.variant;\n    pkt.rot = this.rot;\n    return pkt;\n  }\n\n  getUpdatePkt() {\n    let pkt = super.getUpdatePkt();\n    pkt.rot = this.rot;\n    return pkt;\n  }\n\n  remove() {\n    delete server.list[this.id];\n    super.remove();\n  }\n\n  update() {\n    super.update();\n    let p = this.collision(this.x, this.y, false, 'Player');\n\n    if (p) {\n      this.onHit(p);\n    }\n\n    this.age++;\n    if (this.age >= 1000) {\n      this.remove();\n    }\n  }\n\n  onHit(p) {\n    if (p.id != this.pId) {\n      p.damage(this.damage, p.constructor.list[this.pId]);\n      this.remove();\n    }\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(server.trackName);\n    return inst;\n  }\n\n  static getUpdate() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      if (obj.dirty) pkt[objId] = obj.getUpdatePkt();\n    }\n    return pkt;\n  }\n\n  static getInit() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      pkt[objId] = obj.getInitPkt();\n    }\n    return pkt;\n  }\n\n  static update() {\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      obj.update();\n    }\n  }\n};\n\nclient.list = {};\nserver.list = {};\n\nclient.trackName = server.trackName = \"Projectile\";\n\nmodule.exports = { client, server };\n\n//# sourceURL=webpack:///./client/js/classes/Projectile.js?");

/***/ }),

/***/ "./client/js/classes/Sprite.js":
/*!*************************************!*\
  !*** ./client/js/classes/Sprite.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _extendableBuiltin(cls) {\n  function ExtendableBuiltin() {\n    var instance = Reflect.construct(cls, Array.from(arguments));\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    return instance;\n  }\n\n  ExtendableBuiltin.prototype = Object.create(cls.prototype, {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(ExtendableBuiltin, cls);\n  } else {\n    ExtendableBuiltin.__proto__ = cls;\n  }\n\n  return ExtendableBuiltin;\n}\n\nlet client = class extends _extendableBuiltin(Image) {\n  constructor({ src, name = src.match(/([\\w-]+)(?=\\.(?:png|jpg|jpeg|mpeg|gif))/)[0], w = 32, h = 32, frames = 1, speed = 0 }) {\n    super();\n    //this.ctx = ctx;\n    this.name = name;\n    this.w = w;\n    this.h = h;\n    this.frames = frames;\n    this.index = 0;\n    this.speed = speed;\n    this.path = src;\n    this.loaded = false;\n    this.offScreenC = document.createElement('canvas');\n    this.offScreenC.width = this.w;\n    this.offScreenC.height = this.h;\n    this.offScreen = this.offScreenC.getContext('2d');\n  }\n\n  load(to, indicator) {\n    return new Promise(resolve => {\n      this.onload = () => {\n        to.list.push(this);\n        to.test(indicator);\n        this.loaded = true;\n        resolve();\n      };\n      this.onerror = () => {\n        reject();\n      };\n      this.src = this.path;\n    });\n    // this.onload = ()=>{\n    //   to.test(indicator);\n    //   to.list.push(this);\n    //   this.loaded = true;\n    // }\n    //this.src = this.path;\n  }\n\n  update() {\n    this.index++;\n    this.index = this.index >= this.frames ? 0 : this.index;\n    this.offScreen.drawImage(this, this.index * this.width, 0, this.w, this.h, 0, 0, w, h);\n  }\n\n  get image() {\n    return this.offScreen.toDataURL();\n  }\n\n  draw(canvas, { x, y, w, h, rot }) {\n    canvas.ctx.save();\n    canvas.ctx.translate(x, y);\n    canvas.ctx.rotate(rot);\n    canvas.ctx.drawImage(this, this.index * this.width, 0, this.w, this.h, 0, 0, w, h);\n    canvas.ctx.restore();\n  }\n\n  drawCenter(canvas, { x, y, w, h, rot }) {\n    canvas.ctx.save();\n    canvas.ctx.translate(x, y);\n    canvas.ctx.rotate(rot);\n    canvas.ctx.drawImage(this, this.index * this.width, 0, this.w, this.h, -w / 2, -h / 2, w, h);\n    canvas.ctx.restore();\n  }\n\n};\n\nmodule.exports = { client };\n\n//# sourceURL=webpack:///./client/js/classes/Sprite.js?");

/***/ }),

/***/ "./client/js/classes/SpriteList.js":
/*!*****************************************!*\
  !*** ./client/js/classes/SpriteList.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("let client = class {\n  constructor() {\n    this.list = [];\n    this.total = 0;\n    this.toLoad = [];\n    //this.finLoad = ()=>{;};\n  }\n\n  test(indicator) {\n    indicator.css('width', this.list.length / this.total * 100 + '%');\n    if (this.list.length == this.total) {\n      this.indicator = null;\n    }\n  }\n\n  add(sprite) {\n    this.toLoad.push(sprite);\n    this.total++;\n  }\n\n  load(indicator) {\n    indicator.css('width', '0');\n    let promises = [];\n    for (let sprite of this.toLoad) {\n      promises.push(sprite.load(this, indicator));\n    }\n    return Promise.all(promises);\n  }\n\n  get(name) {\n    return this.list[this.list.findIndex(sp => {\n      return sp.name == name;\n    })];\n  }\n\n  update() {\n    for (let s of this.list) {\n      s.update();\n    }\n  }\n};\n\nmodule.exports = { client };\n\n//# sourceURL=webpack:///./client/js/classes/SpriteList.js?");

/***/ }),

/***/ "./client/js/classes/Trackable.js":
/*!****************************************!*\
  !*** ./client/js/classes/Trackable.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("let uuid;\nif (side == 'SERVER') {\n  uuid = __webpack_require__(/*! uuid/v4 */ \"./node_modules/uuid/v4.js\");\n}\n\nlet client = class {\n  constructor(initPkt) {\n    this.id = initPkt.id;\n\n    client.list[this.id] = this;\n\n    this.update = this.update.bind(this);\n  }\n\n  update(updatePkt) {\n    ;\n    //console.log(updatePkt);\n  }\n\n  remove() {\n    //server.trackList.remove[server.trackName].push(this.id);\n    //if (!global.removePack[this.constructor.trackName].includes(this.id)) global.removePack[this.constructor.trackName].push(this.id);\n    delete this.constructor.list[this.id];\n  }\n\n  get type() {\n    let inst = new Array();\n    inst.push(client.trackName);\n    return inst;\n  }\n\n  // static setTrack(connection, regName){\n  //   client.trackList = connection;\n  //   client.trackList = regName;\n  // }\n\n\n};\n\nclient.trackName = '';\nclient.trackList = {};\nclient.list = {};\n\nlet server = class {\n  constructor(params) {\n    this.id = typeof params.id != \"undefined\" ? params.id : uuid();\n    this.dirty = false;\n\n    server.list[this.id] = this;\n\n    this.markDirty = this.markDirty.bind(this);\n    this.remove = this.remove.bind(this);\n    this.getUpdatePkt = this.getUpdatePkt.bind(this);\n    this.getInitPkt = this.getInitPkt.bind(this);\n  }\n\n  markDirty() {\n    if (this.dirty) return;\n    //console.log(server);\n    //server.trackList.dirty[server.trackName].push(this);\n    this.dirty = true;\n  }\n\n  remove() {\n    //server.trackList.remove[server.trackName].push(this.id);\n    if (!global.removePack[this.constructor.trackName].includes(this.id)) global.removePack[this.constructor.trackName].push(this.id);\n    delete this.constructor.list[this.id];\n  }\n\n  getUpdatePkt() {\n    return { id: this.id };\n  }\n\n  getInitPkt() {\n    return { id: this.id };\n  }\n\n  get type() {\n    let inst = new Array();\n    inst.push(server.trackName);\n    return inst;\n  }\n\n  static update() {\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      obj.update();\n    }\n  }\n\n  static getUpdate() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      if (obj.dirty) pkt[objId] = obj.getUpdatePkt();\n    }\n    return pkt;\n  }\n\n  static getInit() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      if (obj.dirty) pkt[objId] = obj.getInitPkt();\n    }\n    return pkt;\n  }\n\n  static getRemove() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      if (obj.dirty) pkt[objId] = obj.getRemovePkt();\n    }\n    return pkt;\n  }\n\n  // static setTrack(connection, regName){\n  //   server.trackList = connection;\n  //   server.trackName = regName;\n  // }\n\n};\n\nserver.trackName = '';\nserver.trackList = {};\nserver.list = {};\n\n//console.log(server.getUpdate());\n\nmodule.exports = { client, server };\n\n//# sourceURL=webpack:///./client/js/classes/Trackable.js?");

/***/ }),

/***/ "./client/js/classes/Wall.js":
/*!***********************************!*\
  !*** ./client/js/classes/Wall.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EntityProxy = __webpack_require__(/*! ./Entity.js */ \"./client/js/classes/Entity.js\");\n\nlet client = class extends EntityProxy.client {\n  constructor(params) {\n    super(params);\n\n    client.list[this.id] = this;\n  }\n\n  remove() {\n    delete this.constructor.list[this.id];\n    super.remove();\n  }\n\n  render(canvas) {\n    canvas.colour('grey');\n    canvas.centerRect(this);\n    canvas.colour('black');\n    canvas.lineWidth(2);\n    canvas.centerRect(this, true);\n    canvas.minimap.colour('grey');\n    canvas.minimap.centerRect(this);\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(client.trackName);\n    return inst;\n  }\n};\n\nlet server = class extends EntityProxy.server {\n  constructor(params) {\n    params.solid = true;\n    super(params);\n\n    server.list[this.id] = this;\n    initPack[server.trackName][this.id] = this.getInitPkt();\n  }\n\n  getInitPkt() {\n    return super.getInitPkt();\n  }\n\n  getUpdatePkt() {\n    let pkt = super.getUpdatePkt();\n    pkt.w = this.w;\n    pkt.h = this.h;\n    return pkt;\n  }\n\n  get type() {\n    let inst = super.type;\n    inst.push(server.trackName);\n    return inst;\n  }\n\n  static getUpdate() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      if (obj.dirty) pkt[objId] = obj.getUpdatePkt();\n    }\n    return pkt;\n  }\n\n  static getInit() {\n    let pkt = {};\n    for (let objId in server.list) {\n      let obj = server.list[objId];\n      pkt[objId] = obj.getInitPkt();\n    }\n    return pkt;\n  }\n};\n\nclient.trackName = server.trackName = 'Wall';\n\nserver.list = {};\nclient.list = {};\n\nmodule.exports = { client, server };\n\n//# sourceURL=webpack:///./client/js/classes/Wall.js?");

/***/ }),

/***/ "./client/js/main.js":
/*!***************************!*\
  !*** ./client/js/main.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//---DO NOT CHANGE--------------------------------------------------------------\nObject.defineProperty(window, 'side', { value: \"CLIENT\", writeable: false });\n//______________________________________________________________________________\n\n\nconsole.log('Connected to server at ' + location.hostname + ' on port ' + location.port + '.');\n\n// const ConnectionProxy = require('./classes/Connection.js');\n// const {client: Connection} = ConnectionProxy;\n// import React from 'react';\n// import ReactDOM from 'react-dom';\n\nconst SpriteProxy = __webpack_require__(/*! ./classes/Sprite.js */ \"./client/js/classes/Sprite.js\");\nconst { client: Sprite } = SpriteProxy;\nconst SpriteListProxy = __webpack_require__(/*! ./classes/SpriteList.js */ \"./client/js/classes/SpriteList.js\");\nconst { client: SpriteList } = SpriteListProxy;\nconst LoaderListProxy = __webpack_require__(/*! ./classes/LoaderList.js */ \"./client/js/classes/LoaderList.js\");\nconst { client: LoaderList } = LoaderListProxy;\nconst CanvasProxy = __webpack_require__(/*! ./classes/Canvas.js */ \"./client/js/classes/Canvas.js\");\nconst { client: Canvas } = CanvasProxy;\nconst EntityProxy = __webpack_require__(/*! ./classes/Entity.js */ \"./client/js/classes/Entity.js\");\nconst { client: Entity } = EntityProxy;\nEntity.trackName = \"Entity\";\nconst PlayerProxy = __webpack_require__(/*! ./classes/Player.js */ \"./client/js/classes/Player.js\");\nconst { client: Player } = PlayerProxy;\nPlayer.trackName = \"Player\";\nconst ItemProxy = __webpack_require__(/*! ./classes/Item.js */ \"./client/js/classes/Item.js\");\nconst { client: Item } = ItemProxy;\nconst WallProxy = __webpack_require__(/*! ./classes/Wall.js */ \"./client/js/classes/Wall.js\");\nconst { client: Wall } = WallProxy;\nconst ProjectileProxy = __webpack_require__(/*! ./classes/Projectile.js */ \"./client/js/classes/Projectile.js\");\nconst { client: Projectile } = ProjectileProxy;\nconst DecorationProxy = __webpack_require__(/*! ./classes/Decoration.js */ \"./client/js/classes/Decoration.js\");\nconst { client: Decoration } = DecorationProxy;\n\n//const KeyMap = require('./classes/KeyMap.js');\nwindow.KEYS = {};\nconst GAME = { screen: 'login' };\n\nwindow.getClassLists = () => {\n  return {\n    Player: Player.list,\n    Item: Item.list,\n    Wall: Wall.list,\n    Projectile: Projectile.list,\n    Decoration: Decoration.list\n  };\n};\n\n$(() => {\n  const loginTab = $('#page-nav-assist a[href=\"#login-page\"]');\n  const loadTab = $('#page-nav-assist a[href=\"#load-page\"]');\n  const gameTab = $('#page-nav-assist a[href=\"#game-page\"]');\n  const ctx = document.getElementById('gc').getContext('2d');\n  const miniCtx = document.getElementById('mc').getContext('2d');\n  //let miniMap =  new Canvas(miniCtx);\n  const canvas = new Canvas(ctx, miniCtx);\n\n  //let PlayerID;\n\n  canvas.resize({ w: window.innerWidth, h: window.innerHeight });\n\n  $(window).resize(e => {\n    canvas.resize({ w: window.innerWidth, h: window.innerHeight });\n  });\n\n  //---Asset Definition-----------------------------------------------------------\n\n  window.Sprites = new SpriteList();\n  Sprites.add(new Sprite({ ctx, src: '/img/test.png' })); //, name: 'test-sprite'\n  Sprites.add(new Sprite({ ctx, src: '/img/test2.png' }));\n  Sprites.add(new Sprite({ ctx, src: '/img/gold.png', name: 'item_gold', w: 64, h: 64 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/bow.png', name: 'item_bow', w: 64, h: 64 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/arrow.png', name: 'proj_arrow', w: 32, h: 8 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/arrowItem.png', name: 'item_arrow', w: 64, h: 64 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/bandage.png', name: 'item_bandage', w: 64, h: 64 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/level_0.png', name: 'level_0', w: 798, h: 798 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/decoration_tree_0.png', w: 32, h: 32 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/decoration_tree_1.png', w: 32, h: 32 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/decoration_tree_2.png', w: 32, h: 32 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/decoration_tree_3.png', w: 32, h: 32 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/decoration_rock_0.png', w: 32, h: 32 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/decoration_rock_1.png', w: 32, h: 32 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/decoration_rock_2.png', w: 32, h: 32 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/decoration_rock_3.png', w: 32, h: 32 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/wood.png', name: 'item_wood', w: 64, h: 64 }));\n  Sprites.add(new Sprite({ ctx, src: '/img/stone.png', name: 'item_stone', w: 64, h: 64 }));\n\n  const Loader = new LoaderList([Sprites]);\n\n  // const connection = new Connection(socket);\n  // connection.addTrack('Entity', Entity);\n  //______________________________________________________________________________\n\n\n  //---Authentication Listeners---------------------------------------------------\n  socket.on('sign-in-res', res => {\n    $(\"#user\").get(0).setCustomValidity('');\n    $(\"#pass\").get(0).setCustomValidity('');\n    $('#user-feedback').text('');\n    if (res.success) {\n      changeScreen('load');\n      loadTab.tab('show');\n      loadAssets();\n    } else {\n      switch (res.err) {\n        case 'dupe-acc':\n          $('#pass-feedback').text('Error: Duplicate accounts found. Plaese contact the mods.');\n          break;\n\n        case 'incorrect':\n          $('#pass-feedback').text('Incorrect username or password.');\n          break;\n\n        default:\n          $('#pass-feedback').text('Unknown Error. Please contact the mods.');\n      }\n      $(\"#user\").get(0).setCustomValidity('Username Error');\n      $(\"#pass\").get(0).setCustomValidity('Password Error');\n      $(\"#login-form\").addClass('was-validated');\n    }\n  });\n\n  socket.on('sign-up-res', res => {\n    $('#user-feedback').text('');\n    $('#pass-feedback').text('');\n    if (res.success) {\n      $(\"#user\").get(0).setCustomValidity('');\n      $(\"#pass\").get(0).setCustomValidity('');\n      $('#pass-message').text('Sign-up Successful.');\n    } else {\n      switch (res.err) {\n        case 'dupe-acc':\n          $('#user-feedback').text('Username taken. Please try another.');\n          break;\n\n        default:\n          $('#pass-feedback').text('Unknown Error. Please contact the mods.');\n      }\n      $(\"#user\").get(0).setCustomValidity('Username Taken');\n      $(\"#pass\").get(0).setCustomValidity('Password Error');\n    }\n    $(\"#login-form\").addClass('was-validated');\n  });\n\n  $(\"#login-form\").submit(e => {\n    e.preventDefault();\n    $(\"#user\").get(0).setCustomValidity('');\n    $(\"#pass\").get(0).setCustomValidity('');\n    let user = $(\"#user\").val();\n    let pass = $(\"#pass\").val();\n    if (user == '') {\n      $(\"#user\").get(0).setCustomValidity('No Username');\n      $('#user-feedback').text('Please enter a username.');\n      $(\"#login-form\").addClass('was-validated');\n      e.stopPropagation();\n      return false;\n    }\n    if (pass == '') {\n      $(\"#pass\").get(0).setCustomValidity('No Password');\n      $('#pass-feedback').text('Please enter a password.');\n      $(\"#login-form\").addClass('was-validated');\n      e.stopPropagation();\n      return false;\n    }\n    socket.emit('sign-in', { user, pass });\n  });\n\n  $(\"#sign-up\").click(e => {\n    $(\"#user\").get(0).setCustomValidity('');\n    $(\"#pass\").get(0).setCustomValidity('');\n    e.preventDefault();\n    let user = $(\"#user\").val();\n    let pass = $(\"#pass\").val();\n    if (user == '') {\n      $('user-feedback').text('Please enter a username.');\n      e.stopPropagation();\n      return false;\n    }\n    if (pass == '') {\n      $('pass-feedback').text('Please enter a password.');\n      e.stopPropagation();\n      return false;\n    }\n    socket.emit('sign-up', { user, pass });\n  });\n\n  //______________________________________________________________________________\n\n  //---Asset Loading--------------------------------------------------------------\n  function loadAssets() {\n    Loader.load($('#load-bar'), () => {\n      console.log('Finished loading assets.', Loader.loaders);\n      $('#game-page').append($(Loader.loaders[0].list[1]));\n      //connection.begin();\n      socket.emit('loaded', $(\"#user\").val());\n      gameTab.tab('show');\n      changeScreen('game');\n    });\n  }\n  //______________________________________________________________________________\n\n\n  //---Initialization-------------------------------------------------------------\n  socket.on('init', initInfo => {\n    window.PlayerId = initInfo.playerId;\n    for (let pId in initInfo.initPkt.Player) {\n      new Player(initInfo.initPkt.Player[pId]);\n    }\n    for (let iId in initInfo.initPkt.Item) {\n      new Item(initInfo.initPkt.Item[iId]);\n    }\n    for (let wId in initInfo.initPkt.Wall) {\n      new Wall(initInfo.initPkt.Wall[wId]);\n    }\n    for (let pId in initInfo.initPkt.Projectile) {\n      new Projectile(initInfo.initPkt.Projectile[pId]);\n    }\n\n    for (let dId in initInfo.initPkt.Decoration) {\n      new Decoration(initInfo.initPkt.Decoration[dId]);\n    }\n\n    socket.on('update', pkt => {\n      updatePkt(pkt);\n    });\n\n    socket.on('init-pkt', pkt => {\n      initPkt(pkt);\n    });\n\n    socket.on('remove', pkt => {\n      removePkt(pkt);\n    });\n\n    socket.on('chat', msg => {\n      addToChat(msg);\n    });\n\n    socket.on('eval-res', res => {\n      addToChat(res);\n    });\n\n    socket.on('kill', name => {\n      $('#killer').text(name);\n      changeScreen('dead');\n    });\n\n    socket.on('respawn', () => {\n      changeScreen('game');\n    });\n\n    beginRender();\n  });\n\n  function addToChat(msg) {\n    console.log(\"CHAT:  \" + msg);\n    $('#chat-view').append('<div class=\"chat-msg\">' + msg + '</div>');\n    let newMsg = $('#chat-hint').append('<div class=\"chat-msg\">' + msg + '</div>').find(':last-child').show().delay(5000).fadeOut(1000, e => {\n      console.log(e);newMsg.remove();\n    });\n    $('#chat-view').remove('.chat-msg:nth-last-child(1n+50)');\n    $('#chat-hint').remove(':nth-last-child(1n+10)');\n    if ($('#chat-view').scrollTop() >= $(\"#chat-view\").get(0).scrollHeight - $(\"#chat-view\").height() - 40) {\n      console.log('Auto Scrolling', $(\"#chat-view\").get(0).scrollHeight);\n      $('#chat-view').scrollTop($(\"#chat-view\").get(0).scrollHeight);\n    }\n    $('#chat-hint').scrollTop($(\"#chat-hint\").get(0).scrollHeight);\n  }\n  //______________________________________________________________________________\n\n\n  //---Update Handling------------------------------------------------------------\n  function updatePkt(pkt) {\n    //console.log(\"Update\");\n\n    //Players\n    //console.log(pkt.Player);\n    for (let id in pkt.Player) {\n      //console.log(id);\n      let player = Player.list[id];\n      player.update(pkt.Player[id]);\n    }\n\n    for (let id in pkt.Item) {\n      //console.log(id);\n      let item = Item.list[id];\n      item.update(pkt.Item[id]);\n    }\n\n    for (let id in pkt.Wall) {\n      //console.log(id);\n      let wall = Wall.list[id];\n      wall.update(pkt.Wall[id]);\n    }\n\n    for (let id in pkt.Projectile) {\n      let proj = Projectile.list[id];\n      proj.update(pkt.Projectile[id]);\n    }\n    // Decoration.visible = [];\n    // for (let id in pkt.Decoration){\n    //   let deco = Decoration.list[id];\n    //   deco.update(pkt.Decoration[id]);\n    // }\n\n  }\n\n  function initPkt(pkt) {\n    //console.log(pkt);\n\n    //Players\n    for (let id in pkt.Player) {\n      let player = new Player(pkt.Player[id]);\n      //console.log(\"New Player\",player);\n    }\n\n    for (let id in pkt.Item) {\n      let item = new Item(pkt.Item[id]);\n      //console.log(\"New Item\",item);\n    }\n\n    for (let id in pkt.Wall) {\n      let wall = new Wall(pkt.Wall[id]);\n    }\n\n    for (let id in pkt.Projectile) {\n      let proj = new Projectile(pkt.Projectile[id]);\n      console.log('New Projectile');\n    }\n\n    for (let id in pkt.Decoration) {\n      let deco = new Decoration(pkt.Decoration[id]);\n      console.log(\"New Deco\");\n    }\n  }\n\n  function removePkt(pkt) {\n\n    //Players\n    for (let id of pkt.Player) {\n      addToChat(Player.list[id].name + \" left the game.\");\n      Player.list[id].remove();\n    }\n\n    for (let id of pkt.Item) {\n      Item.list[id].remove();\n    }\n\n    for (let id of pkt.Wall) {\n      Wall.list[id].remove();\n    }\n\n    for (let id of pkt.Projectile) {\n      Projectile.list[id].remove();\n    }\n\n    for (let id of pkt.Decoration) {\n      Decoration.list[id].remove();\n    }\n  }\n  //______________________________________________________________________________\n\n  //---Render Loop----------------------------------------------------------------\n  let renderLoop = () => {\n    canvas.clear();\n    let player = Player.list[PlayerId];\n    canvas.camera.setPos(player.x + player.w / 2, player.y + player.h / 2);\n    canvas.update();\n    canvas.background(Sprites.get('level_' + player.world));\n    canvas.colour('black');\n    canvas.lineWidth(2);\n    canvas.ctx.beginPath();\n    canvas.ctx.moveTo(-10, 0);\n    canvas.ctx.lineTo(10, 0);\n    canvas.ctx.moveTo(0, -10);\n    canvas.ctx.lineTo(0, 10);\n    canvas.ctx.stroke();\n\n    for (let dId in Decoration.list) {\n      let d = Decoration.list[dId];\n      d.render(canvas);\n    }\n\n    for (let iId in Item.list) {\n      Item.list[iId].render(canvas);\n    }\n\n    for (let wId in Wall.list) {\n      Wall.list[wId].render(canvas);\n    }\n\n    for (let pId in Projectile.list) {\n      Projectile.list[pId].render(canvas);\n    }\n\n    for (let pId in Player.list) {\n      Player.list[pId].render(canvas);\n    }\n    canvas.reset();\n    renderUI();\n    //console.log(Player.list);\n\n    requestAnimationFrame(renderLoop);\n  };\n\n  function beginRender() {\n    requestAnimationFrame(renderLoop);\n  }\n\n  function renderUI() {\n    let player = Player.list[PlayerId];\n\n    canvas.colour('red');\n    canvas.rect({ x: 20, y: canvas.height - 40, w: 200, h: 20 });\n    canvas.colour('green');\n    canvas.rect({ x: 20, y: canvas.height - 40, w: 200 * (player.health / player.maxHealth), h: 20 });\n    canvas.colour('white');\n    canvas.font('15px Arial');\n    canvas.text(\"\" + player.health + '/' + player.maxHealth, 120, canvas.height - 30);\n\n    canvas.colour('grey');\n    canvas.rect({ x: canvas.width - 220, y: canvas.height - 40, w: 200, h: 20 });\n    canvas.colour('blue');\n    canvas.rect({ x: canvas.width - 220, y: canvas.height - 40, w: 200 * (player.mana / player.maxMana), h: 20 });\n    canvas.colour('white');\n    canvas.font('15px Arial');\n    canvas.text(\"\" + player.mana + '/' + player.maxMana, canvas.width - 120, canvas.height - 30);\n\n    canvas.colour('grey');\n    canvas.rect({ x: 240, y: canvas.height - 40, w: canvas.width - 2 * 240, h: 20 });\n    canvas.colour('lime');\n    canvas.rect({ x: 240, y: canvas.height - 40, w: player.exp / player.toNextL * (canvas.width - 2 * 240), h: 20 });\n    //canvas.colour('white');\n    canvas.font('30px Consolas');\n    canvas.textWO(\"\" + player.level, canvas.width / 2, canvas.height - 45, 'white', 'black');\n\n    canvas.colour('#333333');\n    canvas.rect({ x: canvas.width / 2 - 450, y: 20, w: 900, h: 100 });\n    for (let i in player.inventory.hotbar) {\n      canvas.colour('grey');\n      canvas.lineWidth(1);\n      canvas.rect({ x: canvas.width / 2 - 450 + i * 100, y: 20, w: 100, h: 100 }, true);\n      if (player.inventory.hotbar[i].item != null) Sprites.get('item_' + player.inventory.hotbar[i].item).drawCenter(canvas, { x: canvas.width / 2 - 400 + i * 100, y: 70, w: 64, h: 64 });\n      canvas.colour('white');\n      canvas.font('20px Arial');\n      if (player.inventory.hotbar[i].item != null && player.inventory.hotbar[i].count > 1) canvas.text(player.inventory.hotbar[i].count, canvas.width / 2 - 365 + i * 100, 110);\n    }\n    canvas.colour('#cccccc');\n    canvas.lineWidth(3);\n    canvas.rect({ x: canvas.width / 2 - 450 + player.inventory.selectedSlot * 100, y: 20, w: 100, h: 100 }, true);\n  }\n\n  //______________________________________________________________________________\n\n\n  //---Screens--------------------------------------------------------------------\n  function changeScreen(newScreen) {\n    switch (newScreen) {\n      case \"login\":\n        $('#chat-pane').hide();\n        break;\n\n      case 'load':\n        $('#chat-pane').hide();\n        break;\n\n      case \"game\":\n        $('#chat-pane').hide();\n        $('#chat-input').blur();\n        $('#chat-input').val(\"\");\n        $('#death-screen').hide();\n        break;\n\n      case \"chat\":\n        $('#chat-pane').show();\n        $('#chat-view .chat-msg').show();\n        console.log('Auto Scrolling', $(\"#chat-view\").get(0).scrollHeight);\n        $('#chat-view').scrollTop($(\"#chat-view\").get(0).scrollHeight);\n        $('#chat-input').focus();\n        break;\n\n      case 'dead':\n        $('#chat-pane').hide();\n        $('#chat-input').blur();\n        $('#chat-input').val(\"\");\n        $('#death-screen').show();\n        break;\n    }\n    GAME.screen = newScreen;\n  }\n  //______________________________________________________________________________\n\n  //---Event Listiners------------------------------------------------------------\n  canvas.canvas.mousedown(e => {\n    e.preventDefault();\n    socket.emit('mousedown', { x: e.offsetX + canvas.camera.x - canvas.width / 2, y: e.offsetY + canvas.camera.y - canvas.height / 2, button: e.button });\n  });\n\n  canvas.canvas.mouseup(e => {\n    e.preventDefault();\n    socket.emit('mouseup', { x: e.offsetX + canvas.camera.x - canvas.width / 2, y: e.offsetY + canvas.camera.y - canvas.height / 2, button: e.button });\n  });\n\n  canvas.canvas.bind('contextmenu', e => {\n    e.preventDefault();\n  });\n\n  $(document).keydown(e => {\n    KEYS[e.key.toUpperCase()] = true;\n    console.log(e.key.toUpperCase());\n    if (KEYS[String.fromCharCode(0x5C)]) {\n\n      //console.log('opening chat', GAME.screen);\n      if (GAME.screen == 'game') {\n        changeScreen('chat');e.preventDefault();\n      } //else if (GAME.screen == 'chat') {changeScreen('game')};\n    }\n\n    if (KEYS['ESCAPE']) {\n      if (GAME.screen != 'game') {\n        changeScreen('game');\n      }\n    }\n    //console.log(KEYS);\n    socket.emit('key', KEYS);\n  });\n\n  $(document).keyup(e => {\n    KEYS[e.key.toUpperCase()] = false;\n    //console.log(KEYS);\n    socket.emit('key', KEYS);\n  });\n\n  $(\"#chat-form\").submit(e => {\n    e.preventDefault();\n    let val = $('#chat-input').val();\n    if (val.charAt(0) == \"/\") {\n      socket.emit('eval', val.slice(1));\n    } else {\n      socket.emit('chat', val);\n    }\n    $('#chat-history').append(\"<option value='\" + val.replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\") + \"'>\");\n    changeScreen('game');\n  });\n  //______________________________________________________________________________\n});\n\n//# sourceURL=webpack:///./client/js/main.js?");

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n//# sourceURL=webpack:///./node_modules/uuid/lib/bytesToUuid.js?");

/***/ }),

/***/ "./node_modules/uuid/lib/rng.js":
/*!**************************************!*\
  !*** ./node_modules/uuid/lib/rng.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n\n\n//# sourceURL=webpack:///./node_modules/uuid/lib/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n//# sourceURL=webpack:///./node_modules/uuid/v4.js?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ })

/******/ });